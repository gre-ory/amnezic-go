package util

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strings"

	"go.uber.org/zap"
)

// //////////////////////////////////////////////////
// sql table

type SqlTable[Row any] interface {
	ListRows(ctx context.Context, tx *sql.Tx, wc SqlWhereClause) []*Row
	InsertRow(ctx context.Context, tx *sql.Tx, row *Row) *Row
	SelectRow(ctx context.Context, tx *sql.Tx, wc SqlWhereClause) (*Row, error)
	ExistsRow(ctx context.Context, tx *sql.Tx, wc SqlWhereClause) bool
	UpdateRow(ctx context.Context, tx *sql.Tx, row *Row, wc SqlWhereClause) *Row
	DeleteRows(ctx context.Context, tx *sql.Tx, wc SqlWhereClause) int64
}

func NewSqlTable[Row any](logger *zap.Logger, name string, errNotFound error) *sqlTable[Row] {
	logger = logger.With(zap.String("table", name))
	return &sqlTable[Row]{
		logger:      logger,
		name:        name,
		columns:     extractSqlColumns[Row](logger),
		errNotFound: errNotFound,
	}
}

type sqlTable[Row any] struct {
	logger      *zap.Logger
	name        string
	columns     []sqlColumn
	errNotFound error
}

type sqlColumn struct {
	Index         int
	ReadOnly      bool
	AutoGenerated bool
	Name          string
}

// //////////////////////////////////////////////////
// errors

var (
	ErrMissingSqlRow      = fmt.Errorf("missing sql row")
	ErrMissingWhereClause = fmt.Errorf("missing where clause")
)

// //////////////////////////////////////////////////
// list rows

func (t *sqlTable[Row]) ListRows(ctx context.Context, tx *sql.Tx, wc SqlWhereClause) []*Row {

	returningColumns := make([]string, 0, len(t.columns))

	for _, column := range t.columns {
		returningColumns = append(returningColumns, column.Name)
	}

	whereClause, whereClauseArgs := wc.Generate(0)

	query := fmt.Sprintf(
		"SELECT %s FROM %s %s",
		strings.Join(returningColumns, ","),
		t.name,
		whereClause,
	)
	t.logger.Info(fmt.Sprintf("[DEBUG] query: %s, args: %#v", query, whereClauseArgs))

	stmt, err := tx.Prepare(query) // to avoid SQL injection
	if err != nil {
		panic(err)
	}

	rows, err := stmt.Query(whereClauseArgs...)
	if err != nil {
		panic(err)
	}
	defer rows.Close()

	result := make([]*Row, 0)
	for rows.Next() {
		result = append(result, t.scanRow(ctx, rows))
	}
	return result
}

// //////////////////////////////////////////////////
// insert row

func (t *sqlTable[Row]) InsertRow(ctx context.Context, tx *sql.Tx, row *Row) *Row {

	if row == nil {
		panic(ErrMissingSqlRow)
	}
	reflectValue := reflect.ValueOf(row).Elem()

	t.logger.Info(fmt.Sprintf("[DEBUG] columns: %#v", t.columns))

	returningColumns := make([]string, 0, len(t.columns))
	insertColumns := make([]string, 0, len(t.columns))
	placeholders := make([]string, 0, len(t.columns))
	args := make([]any, 0, len(t.columns))

	for _, column := range t.columns {
		returningColumns = append(returningColumns, column.Name)
		if column.AutoGenerated {
			continue
		}
		insertColumns = append(insertColumns, column.Name)
		placeholders = append(placeholders, fmt.Sprintf("$%d", len(args)+1))
		arg := reflectValue.Field(column.Index).Interface()
		args = append(args, arg)
	}

	query := fmt.Sprintf(
		"INSERT INTO %s (%s) VALUES (%s) RETURNING %s",
		t.name,
		strings.Join(insertColumns, ","),
		strings.Join(placeholders, ","),
		strings.Join(returningColumns, ","),
	)
	t.logger.Info(fmt.Sprintf("[DEBUG] query: %s, args: %#v", query, args))

	stmt, err := tx.Prepare(query) // to avoid SQL injection
	if err != nil {
		panic(err)
	}

	rows, err := stmt.Query(args...)
	if err != nil {
		panic(err)
	}
	defer rows.Close()

	for rows.Next() {
		return t.scanRow(ctx, rows)
	}

	panic(t.errNotFound)
}

// //////////////////////////////////////////////////
// select row

func (t *sqlTable[Row]) SelectRow(ctx context.Context, tx *sql.Tx, wc SqlWhereClause) (*Row, error) {

	returningColumns := make([]string, 0, len(t.columns))

	for _, column := range t.columns {
		returningColumns = append(returningColumns, column.Name)
	}

	if wc.IsEmpty() {
		panic(ErrMissingWhereClause)
	}
	whereClause, whereClauseArgs := wc.Generate(0)

	query := fmt.Sprintf(
		"SELECT %s FROM %s %s LIMIT 1",
		strings.Join(returningColumns, ","),
		t.name,
		whereClause,
	)
	t.logger.Info(fmt.Sprintf("[DEBUG] query: %s, args: %#v", query, whereClauseArgs))

	stmt, err := tx.Prepare(query) // to avoid SQL injection
	if err != nil {
		panic(err)
	}

	rows, err := stmt.Query(whereClauseArgs...)
	if err != nil {
		panic(err)
	}
	defer rows.Close()

	for rows.Next() {
		return t.scanRow(ctx, rows), nil
	}
	return nil, t.errNotFound
}

// //////////////////////////////////////////////////
// exists row

func (t *sqlTable[Row]) ExistsRow(ctx context.Context, tx *sql.Tx, wc SqlWhereClause) bool {

	if wc.IsEmpty() {
		panic(ErrMissingWhereClause)
	}
	whereClause, whereClauseArgs := wc.Generate(0)

	query := fmt.Sprintf(
		"SELECT EXISTS( SELECT 1 FROM %s %s )",
		t.name,
		whereClause,
	)
	t.logger.Info(fmt.Sprintf("[DEBUG] query: %s, args: %#v", query, whereClauseArgs))

	stmt, err := tx.Prepare(query) // to avoid SQL injection
	if err != nil {
		panic(err)
	}

	rows, err := stmt.Query(whereClauseArgs...)
	if err != nil {
		panic(err)
	}
	defer rows.Close()

	for rows.Next() {
		var exists bool
		rows.Scan(&exists)
		return exists
	}

	return false
}

// //////////////////////////////////////////////////
// update row

func (t *sqlTable[Row]) UpdateRow_Off(ctx context.Context, tx *sql.Tx, row *Row, wc SqlWhereClause) *Row {

	if row == nil {
		panic(ErrMissingSqlRow)
	}
	reflectValue := reflect.ValueOf(row).Elem()

	returningColumns := make([]string, 0, len(t.columns))
	setValues := make([]string, 0, len(t.columns))

	if wc.IsEmpty() {
		panic(ErrMissingWhereClause)
	}
	whereClause, whereClauseArgs := wc.Generate(0)

	args := whereClauseArgs

	for _, column := range t.columns {
		returningColumns = append(returningColumns, column.Name)
		if column.AutoGenerated || column.ReadOnly {
			continue
		}
		setValues = append(setValues, fmt.Sprintf("%s=$%d", column.Name, len(args)+1))
		arg := reflectValue.Field(column.Index).Interface()
		args = append(args, arg)
	}

	query := fmt.Sprintf(
		"UPDATE %s SET %s %s RETURNING %s", //  LIMIT 1
		t.name,
		strings.Join(setValues, ","),
		whereClause,
		strings.Join(returningColumns, ","),
	)
	t.logger.Info(fmt.Sprintf("[DEBUG] query: %s, args: %#v", query, args))

	stmt, err := tx.Prepare(query) // to avoid SQL injection
	if err != nil {
		panic(err)
	}

	rows, err := stmt.Query(args...)
	if err != nil {
		panic(err)
	}
	defer rows.Close()

	var result *Row
	for rows.Next() {
		result = t.scanRow(ctx, rows)
		t.logger.Info(fmt.Sprintf("[DEBUG] result = %#v", result))
	}
	t.logger.Info(fmt.Sprintf("[DEBUG] >>> result = %#v", result))
	return result

	// panic(t.errNotFound)
	// return nil
}

func (t *sqlTable[Row]) UpdateRow(ctx context.Context, tx *sql.Tx, row *Row, wc SqlWhereClause) *Row {

	if row == nil {
		panic(ErrMissingSqlRow)
	}
	reflectValue := reflect.ValueOf(row).Elem()

	returningColumns := make([]string, 0, len(t.columns))
	setValues := make([]string, 0, len(t.columns))

	placeHolder := 0
	args := make([]any, 0, len(t.columns))
	for _, column := range t.columns {
		returningColumns = append(returningColumns, column.Name)
		if column.AutoGenerated || column.ReadOnly {
			continue
		}
		placeHolder++
		setValues = append(setValues, fmt.Sprintf("%s=$%d", column.Name, placeHolder))
		arg := reflectValue.Field(column.Index).Interface()
		args = append(args, arg)
	}

	if wc.IsEmpty() {
		panic(ErrMissingWhereClause)
	}
	whereClause, whereClauseArgs := wc.Generate(placeHolder)
	args = append(args, whereClauseArgs...)

	query := fmt.Sprintf(
		"UPDATE %s SET %s %s RETURNING %s", //  LIMIT 1
		t.name,
		strings.Join(setValues, ","),
		whereClause,
		strings.Join(returningColumns, ","),
	)
	t.logger.Info(fmt.Sprintf("[DEBUG] query: %s, args: %#v", query, args))

	stmt, err := tx.Prepare(query) // to avoid SQL injection
	if err != nil {
		panic(err)
	}

	rows, err := stmt.Query(args...)
	if err != nil {
		panic(err)
	}
	defer rows.Close()

	var result *Row
	for rows.Next() {
		result = t.scanRow(ctx, rows)
		t.logger.Info(fmt.Sprintf("[DEBUG] result = %#v", result))
	}
	t.logger.Info(fmt.Sprintf("[DEBUG] >>> result = %#v", result))
	return result

	// panic(t.errNotFound)
	// return nil
}

// //////////////////////////////////////////////////
// delete rows

func (t *sqlTable[Row]) DeleteRows(ctx context.Context, tx *sql.Tx, wc SqlWhereClause) int64 {

	whereClause, whereClauseArgs := wc.Generate(0)

	query := fmt.Sprintf(
		"DELETE FROM %s %s",
		t.name,
		whereClause,
	)
	t.logger.Info(fmt.Sprintf("[DEBUG] query: %s, args: %#v", query, whereClauseArgs))

	stmt, err := tx.Prepare(query) // to avoid SQL injection
	if err != nil {
		panic(err)
	}

	result, err := stmt.Exec(whereClauseArgs...)
	if err != nil {
		panic(err)
	}

	nb, err := result.RowsAffected()
	if err != nil {
		panic(err)
	}
	return nb
}

// //////////////////////////////////////////////////
// scan row

func (t *sqlTable[Row]) scanRow(ctx context.Context, rows *sql.Rows) *Row {

	var row Row
	reflectValue := reflect.ValueOf(&row).Elem()

	ptrs := make([]any, 0, len(t.columns))
	for _, column := range t.columns {
		ptr := reflectValue.Field(column.Index).Addr().Interface()
		ptrs = append(ptrs, ptr)
	}

	rows.Scan(ptrs...)

	return &row
}

// //////////////////////////////////////////////////
// extract sql columns

func extractSqlColumns[R any](logger *zap.Logger) []sqlColumn {

	var row R
	reflectType := reflect.TypeOf(row)
	n := reflectType.NumField()
	columns := make([]sqlColumn, 0, n)
	for i := 0; i < n; i++ {
		reflectField := reflectType.Field(i)
		column := extractSqlColumn(i, reflectField)
		if column.Name == "" {
			logger.Warn(fmt.Sprintf("[DEBUG] (-) invalid column: %#v", column))
		} else {
			logger.Info(fmt.Sprintf("[DEBUG] (+) column: %#v", column))
			columns = append(columns, column)
		}
	}
	return columns
}

// //////////////////////////////////////////////////
// extract sql column

func extractSqlColumn(index int, field reflect.StructField) sqlColumn {
	tag := field.Tag.Get("sql")
	splits := strings.Split(tag, ",")
	return sqlColumn{
		Index:         index,
		Name:          splits[0],
		AutoGenerated: Contains(splits, "auto-generated"),
		ReadOnly:      Contains(splits, "read-only"),
	}
}
