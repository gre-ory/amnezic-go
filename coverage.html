
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gre-ory/amnezic-go/internal/client/deezer_client.go (78.6%)</option>
				
				<option value="file1">github.com/gre-ory/amnezic-go/internal/model/game_answer.go (0.0%)</option>
				
				<option value="file2">github.com/gre-ory/amnezic-go/internal/model/game_id.go (100.0%)</option>
				
				<option value="file3">github.com/gre-ory/amnezic-go/internal/model/game_player.go (0.0%)</option>
				
				<option value="file4">github.com/gre-ory/amnezic-go/internal/model/game_question.go (0.0%)</option>
				
				<option value="file5">github.com/gre-ory/amnezic-go/internal/model/game_settings.go (0.0%)</option>
				
				<option value="file6">github.com/gre-ory/amnezic-go/internal/model/game_theme.go (0.0%)</option>
				
				<option value="file7">github.com/gre-ory/amnezic-go/internal/model/music.go (0.0%)</option>
				
				<option value="file8">github.com/gre-ory/amnezic-go/internal/model/music_album.go (0.0%)</option>
				
				<option value="file9">github.com/gre-ory/amnezic-go/internal/model/music_artist.go (0.0%)</option>
				
				<option value="file10">github.com/gre-ory/amnezic-go/internal/model/music_genre.go (0.0%)</option>
				
				<option value="file11">github.com/gre-ory/amnezic-go/internal/model/source.go (0.0%)</option>
				
				<option value="file12">github.com/gre-ory/amnezic-go/internal/model/theme.go (0.0%)</option>
				
				<option value="file13">github.com/gre-ory/amnezic-go/internal/model/theme_filter.go (0.0%)</option>
				
				<option value="file14">github.com/gre-ory/amnezic-go/internal/model/theme_question.go (0.0%)</option>
				
				<option value="file15">github.com/gre-ory/amnezic-go/internal/model/theme_question_filter.go (0.0%)</option>
				
				<option value="file16">github.com/gre-ory/amnezic-go/internal/store/game_memory_store.go (0.0%)</option>
				
				<option value="file17">github.com/gre-ory/amnezic-go/internal/store/game_question_legacy_store.go (90.3%)</option>
				
				<option value="file18">github.com/gre-ory/amnezic-go/internal/store/music_album_memory_store.go (0.0%)</option>
				
				<option value="file19">github.com/gre-ory/amnezic-go/internal/store/music_artist_memory_store.go (0.0%)</option>
				
				<option value="file20">github.com/gre-ory/amnezic-go/internal/store/music_genre_memory_store.go (0.0%)</option>
				
				<option value="file21">github.com/gre-ory/amnezic-go/internal/store/music_memory_store.go (0.0%)</option>
				
				<option value="file22">github.com/gre-ory/amnezic-go/internal/store/theme_memory_store.go (0.0%)</option>
				
				<option value="file23">github.com/gre-ory/amnezic-go/internal/store/theme_question_memory_store.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package client

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"

        "github.com/gre-ory/amnezic-go/internal/model"
        "github.com/gre-ory/amnezic-go/internal/util"
        "go.uber.org/zap"
)

// //////////////////////////////////////////////////
// deezer client

type DeezerClient interface {
        Search(query string, limit int) ([]*model.Music, error)
        GetTrack(trackId model.DeezerMusicId) (*model.Music, error)
}

func NewDeezerClient(logger *zap.Logger) DeezerClient <span class="cov10" title="2">{
        return &amp;deezerClient{
                logger: logger,
        }
}</span>

type deezerClient struct {
        logger *zap.Logger
}

// //////////////////////////////////////////////////
// search

func (c *deezerClient) Search(query string, limit int) ([]*model.Music, error) <span class="cov1" title="1">{

        url := fmt.Sprintf("https://api.deezer.com/search?q=%s&amp;limit=%d", url.QueryEscape(query), limit)
        resp, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()

        var jsonSearch JsonDeezerSearch
        err = json.NewDecoder(resp.Body).Decode(&amp;jsonSearch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return util.Convert(jsonSearch.Tracks, toMusic), nil</span>
}

// //////////////////////////////////////////////////
// track

func (c *deezerClient) GetTrack(trackId model.DeezerMusicId) (*model.Music, error) <span class="cov1" title="1">{

        url := fmt.Sprintf("https://api.deezer.com/track/%d", trackId)
        resp, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()

        var jsonTrack JsonDeezerTrack
        err = json.NewDecoder(resp.Body).Decode(&amp;jsonTrack)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return toMusic(&amp;jsonTrack), nil</span>
}

// //////////////////////////////////////////////////
// adapter

func toMusic(jsonTrack *JsonDeezerTrack) *model.Music <span class="cov10" title="2">{
        return &amp;model.Music{
                DeezerMusicId: model.DeezerMusicId(jsonTrack.Id),
                Name:          jsonTrack.Title,
                Mp3Url:        jsonTrack.Preview,
                Artist:        toArtist(jsonTrack.Artist),
                Album:         toAlbum(jsonTrack.Album),
        }
}</span>

func toArtist(jsonArtist *JsonDeezerArtist) *model.MusicArtist <span class="cov10" title="2">{
        if jsonArtist == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov10" title="2">return &amp;model.MusicArtist{
                DeezerArtistId: model.DeezerArtistId(jsonArtist.Id),
                Name:           jsonArtist.Name,
                ImgUrl:         jsonArtist.Picture,
        }</span>
}

func toAlbum(jsonAlbum *JsonDeezerAlbum) *model.MusicAlbum <span class="cov10" title="2">{
        if jsonAlbum == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov10" title="2">return &amp;model.MusicAlbum{
                DeezerAlbumId: model.DeezerAlbumId(jsonAlbum.Id),
                Name:          jsonAlbum.Title,
                ImgUrl:        jsonAlbum.Cover,
        }</span>
}

// //////////////////////////////////////////////////
// json

type JsonDeezerSearch struct {
        Tracks []*JsonDeezerTrack `json:"data"`
}

type JsonDeezerTrack struct {
        Id                 int64                    `json:"id"`
        Readable           bool                     `json:"readable"`
        Title              string                   `json:"title"`
        TitleShort         string                   `json:"title_short"`
        Duration           int64                    `json:"duration"`
        Preview            string                   `json:"preview"`
        AvailableCountries []string                 `json:"available_countries"`
        Contributors       []*JsonDeezerContributor `json:"contributors"`
        Artist             *JsonDeezerArtist        `json:"artist"`
        Album              *JsonDeezerAlbum         `json:"album"`
}

type JsonDeezerContributor struct {
        Id      int64  `json:"id"`
        Name    string `json:"name"`
        Picture string `json:"picture"`
        Type    string `json:"type"`
        Role    string `json:"role"`
}

type JsonDeezerArtist struct {
        Id      int64  `json:"id"`
        Name    string `json:"name"`
        Picture string `json:"picture"`
        Type    string `json:"type"`
        Role    string `json:"role"`
}

type JsonDeezerAlbum struct {
        Id    int64  `json:"id"`
        Title string `json:"title"`
        Cover string `json:"cover"`
        Type  string `json:"type"`
        Role  string `json:"role"`
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package model

import "go.uber.org/zap/zapcore"

// //////////////////////////////////////////////////
// game answer

type GameAnswer struct {
        Id      GameAnswerId
        Text    string
        Hint    string
        Correct bool
}

func (o *GameAnswer) Copy() *GameAnswer <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;GameAnswer{
                Id:      o.Id,
                Text:    o.Text,
                Hint:    o.Hint,
                Correct: o.Correct,
        }</span>
}

func (o *GameAnswer) MarshalLogObject(enc zapcore.ObjectEncoder) error <span class="cov0" title="0">{
        enc.AddInt64("id", int64(o.Id))
        enc.AddString("text", o.Text)
        if o.Hint != "" </span><span class="cov0" title="0">{
                enc.AddString("hint", o.Hint)
        }</span>
        <span class="cov0" title="0">if o.Correct </span><span class="cov0" title="0">{
                enc.AddBool("correct", o.Correct)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package model

// //////////////////////////////////////////////////
// constants

const (
        GameIdStart     = 10000000
        QuestionIdStart = 10000
        AnswerIdStart   = 100
        PlayerIdStart   = 1
)

// //////////////////////////////////////////////////
// game id

type GameId int64

func NewGameId(number int) GameId <span class="cov8" title="5">{
        return GameId(GameIdStart * number)
}</span>

// //////////////////////////////////////////////////
// game question id

type GameQuestionId int64

func NewGameQuestionId(gameId GameId, number int) GameQuestionId <span class="cov7" title="4">{
        return GameQuestionId(int64(gameId) + int64(QuestionIdStart*number))
}</span>

func (id GameQuestionId) Split() GameId <span class="cov1" title="1">{
        gameId := GameId((id / GameIdStart) * GameIdStart)
        return gameId
}</span>

// //////////////////////////////////////////////////
// game answer id

type GameAnswerId int64

func NewGameAnswerId(questionId GameQuestionId, number int) GameAnswerId <span class="cov7" title="4">{
        return GameAnswerId(int64(questionId) + int64(AnswerIdStart*number))
}</span>

func (id GameAnswerId) Split() (GameId, GameQuestionId) <span class="cov1" title="1">{
        gameId := GameId((id / GameIdStart) * GameIdStart)
        questionId := GameQuestionId((id / QuestionIdStart) * QuestionIdStart)
        return gameId, questionId
}</span>

// //////////////////////////////////////////////////
// player answer id

type GamePlayerAnswerId int64

func NewGamePlayerAnswerId(answerId GameAnswerId, playerId GamePlayerId) GamePlayerAnswerId <span class="cov7" title="4">{
        return GamePlayerAnswerId(int64(answerId) + int64(playerId))
}</span>

func (id GamePlayerAnswerId) Split() (GameId, GameQuestionId, GameAnswerId, GamePlayerId) <span class="cov1" title="1">{
        gameId := GameId((id / GameIdStart) * GameIdStart)
        questionId := GameQuestionId((id / QuestionIdStart) * QuestionIdStart)
        answerId := GameAnswerId((id / AnswerIdStart) * AnswerIdStart)
        playerId := GamePlayerId(id % AnswerIdStart)
        return gameId, questionId, answerId, playerId
}</span>

// //////////////////////////////////////////////////
// game player id

type GamePlayerId int64

func NewGamePlayerId(number int) GamePlayerId <span class="cov10" title="7">{
        return GamePlayerId(PlayerIdStart * number)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package model

import "go.uber.org/zap/zapcore"

// //////////////////////////////////////////////////
// game player

type GamePlayer struct {
        Id     GamePlayerId
        Name   string
        Active bool
        Score  int
}

func (o *GamePlayer) Copy() *GamePlayer <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;GamePlayer{
                Id:     o.Id,
                Name:   o.Name,
                Active: o.Active,
                Score:  o.Score,
        }</span>
}

func (o *GamePlayer) MarshalLogObject(enc zapcore.ObjectEncoder) error <span class="cov0" title="0">{
        enc.AddInt64("id", int64(o.Id))
        enc.AddString("name", o.Name)
        enc.AddInt("score", o.Score)
        enc.AddBool("active", o.Active)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package model

import (
        "github.com/gre-ory/amnezic-go/internal/util"
        "go.uber.org/zap/zapcore"
)

// //////////////////////////////////////////////////
// game question

type GameQuestion struct {
        Id      GameQuestionId
        Theme   *GameTheme
        Music   *Music
        Answers []*GameAnswer
}

func (o *GameQuestion) Copy() *GameQuestion <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;GameQuestion{
                Id:      o.Id,
                Theme:   o.Theme.Copy(),
                Music:   o.Music.Copy(),
                Answers: util.Convert(o.Answers, (*GameAnswer).Copy),
        }</span>
}

func (o *GameQuestion) MarshalLogObject(enc zapcore.ObjectEncoder) error <span class="cov0" title="0">{
        enc.AddInt64("id", int64(o.Id))
        enc.AddObject("theme", o.Theme)
        enc.AddObject("music", o.Music)
        enc.AddInt("nb-answers", len(o.Answers))
        return nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package model

import (
        "github.com/gre-ory/amnezic-go/internal/util"
        "go.uber.org/zap/zapcore"
)

// //////////////////////////////////////////////////
// game settings

type GameSettings struct {
        Seed       int64
        NbQuestion int
        NbAnswer   int
        NbPlayer   int
        Sources    []Source
}

func (o *GameSettings) MarshalLogObject(enc zapcore.ObjectEncoder) error <span class="cov0" title="0">{
        enc.AddInt64("seed", o.Seed)
        enc.AddInt("nb-question", o.NbQuestion)
        enc.AddInt("nb-answer", o.NbAnswer)
        enc.AddInt("nb-player", o.NbPlayer)
        enc.AddString("sources", util.Join(o.Sources, Source.String))
        return nil
}</span>

// //////////////////////////////////////////////////
// validate

const (
        MinNbPlayer = 2
        MaxNbPlayer = 99

        MinNbQuestion = 1
        MaxNbQuestion = 999

        MinNbAnswer = 2
        MaxNbAnswer = 99
)

func (o *GameSettings) Validate() error <span class="cov0" title="0">{
        if o.NbPlayer &lt; MinNbPlayer || o.NbPlayer &gt; MaxNbPlayer </span><span class="cov0" title="0">{
                return ErrInvalidNbPlayer
        }</span>
        <span class="cov0" title="0">if o.NbQuestion &lt; MinNbQuestion || o.NbQuestion &gt; MaxNbQuestion </span><span class="cov0" title="0">{
                return ErrInvalidNbQuestion
        }</span>
        <span class="cov0" title="0">if o.NbAnswer &lt; MinNbAnswer || o.NbAnswer &gt; MaxNbAnswer </span><span class="cov0" title="0">{
                return ErrInvalidNbAnswer
        }</span>
        <span class="cov0" title="0">if len(o.Sources) == 0 </span><span class="cov0" title="0">{
                return ErrMissingSource
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package model

import (
        "go.uber.org/zap/zapcore"
)

// //////////////////////////////////////////////////
// game theme

type GameTheme struct {
        Id     int64
        Title  string
        ImgUrl string
}

func (o *GameTheme) Copy() *GameTheme <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;GameTheme{
                Id:     o.Id,
                Title:  o.Title,
                ImgUrl: o.ImgUrl,
        }</span>
}

func (o *GameTheme) MarshalLogObject(enc zapcore.ObjectEncoder) error <span class="cov0" title="0">{
        enc.AddInt64("id", int64(o.Id))
        enc.AddString("title", o.Title)
        enc.AddString("img-url", o.ImgUrl)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package model

import (
        "go.uber.org/zap/zapcore"
)

// //////////////////////////////////////////////////
// music

type MusicId int64

type DeezerMusicId int64

type Music struct {
        Id            MusicId
        DeezerMusicId DeezerMusicId
        Name          string
        Mp3Url        string
        ArtistId      MusicArtistId
        AlbumId       MusicAlbumId
        GenreId       MusicGenreId

        // consolidated data
        Artist *MusicArtist
        Album  *MusicAlbum
        Genre  *MusicGenre
}

func (o *Music) Copy() *Music <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;Music{
                Id:            o.Id,
                DeezerMusicId: o.DeezerMusicId,
                Name:          o.Name,
                Mp3Url:        o.Mp3Url,
                ArtistId:      o.ArtistId,
                AlbumId:       o.AlbumId,
                GenreId:       o.GenreId,
        }</span>
}

func (o *Music) MarshalLogObject(enc zapcore.ObjectEncoder) error <span class="cov0" title="0">{
        enc.AddInt64("id", int64(o.Id))
        if o.DeezerMusicId != 0 </span><span class="cov0" title="0">{
                enc.AddInt64("deezer-music-id", int64(o.DeezerMusicId))
        }</span>
        <span class="cov0" title="0">enc.AddString("name", o.Name)
        enc.AddString("mp3-url", o.Mp3Url)
        if o.Artist != nil </span><span class="cov0" title="0">{
                enc.AddObject("artist", o.Artist)
        }</span>
        <span class="cov0" title="0">if o.Album != nil </span><span class="cov0" title="0">{
                enc.AddObject("album", o.Album)
        }</span>
        <span class="cov0" title="0">if o.Genre != nil </span><span class="cov0" title="0">{
                enc.AddObject("genre", o.Genre)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package model

import "go.uber.org/zap/zapcore"

// //////////////////////////////////////////////////
// music album

type MusicAlbumId int64

type DeezerAlbumId int64

type MusicAlbum struct {
        Id            MusicAlbumId
        DeezerAlbumId DeezerAlbumId
        Name          string
        ImgUrl        string
}

func (o *MusicAlbum) Copy() *MusicAlbum <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;MusicAlbum{
                Id:            o.Id,
                DeezerAlbumId: o.DeezerAlbumId,
                Name:          o.Name,
                ImgUrl:        o.ImgUrl,
        }</span>
}

func (o *MusicAlbum) MarshalLogObject(enc zapcore.ObjectEncoder) error <span class="cov0" title="0">{
        enc.AddInt64("id", int64(o.Id))
        if o.DeezerAlbumId != 0 </span><span class="cov0" title="0">{
                enc.AddInt64("deezer-album-id", int64(o.DeezerAlbumId))
        }</span>
        <span class="cov0" title="0">enc.AddString("name", o.Name)
        enc.AddString("img-url", o.ImgUrl)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package model

import "go.uber.org/zap/zapcore"

// //////////////////////////////////////////////////
// music artist

type MusicArtistId int64

type DeezerArtistId int64

type MusicArtist struct {
        Id             MusicArtistId
        DeezerArtistId DeezerArtistId
        Name           string
        ImgUrl         string
}

func (o *MusicArtist) Copy() *MusicArtist <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;MusicArtist{
                Id:             o.Id,
                DeezerArtistId: o.DeezerArtistId,
                Name:           o.Name,
                ImgUrl:         o.ImgUrl,
        }</span>
}

func (o *MusicArtist) MarshalLogObject(enc zapcore.ObjectEncoder) error <span class="cov0" title="0">{
        enc.AddInt64("id", int64(o.Id))
        if o.DeezerArtistId != 0 </span><span class="cov0" title="0">{
                enc.AddInt64("deezer-artist-id", int64(o.DeezerArtistId))
        }</span>
        <span class="cov0" title="0">enc.AddString("name", o.Name)
        enc.AddString("img-url", o.ImgUrl)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package model

import "go.uber.org/zap/zapcore"

// //////////////////////////////////////////////////
// music genre

type MusicGenreId int64

type DeezerGenreId int64

type MusicGenre struct {
        Id            MusicGenreId
        DeezerGenreId DeezerGenreId
        Name          string
        ImgUrl        string
}

func (o *MusicGenre) Copy() *MusicGenre <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;MusicGenre{
                Id:            o.Id,
                DeezerGenreId: o.DeezerGenreId,
                Name:          o.Name,
                ImgUrl:        o.ImgUrl,
        }</span>
}

func (o *MusicGenre) MarshalLogObject(enc zapcore.ObjectEncoder) error <span class="cov0" title="0">{
        enc.AddInt64("id", int64(o.Id))
        if o.DeezerGenreId != 0 </span><span class="cov0" title="0">{
                enc.AddInt64("deezer-genre-id", int64(o.DeezerGenreId))
        }</span>
        <span class="cov0" title="0">enc.AddString("name", o.Name)
        enc.AddString("img-url", o.ImgUrl)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package model

import "strings"

// //////////////////////////////////////////////////
// source

type Source string

var (
        Source_Legacy Source = "legacy"
        Source_Decade Source = "decade"
        Source_Genre  Source = "genre"
        Source_Deezer Source = "deezer"
)

func ToSource(value string) Source <span class="cov0" title="0">{
        value = strings.Trim(value, " ")
        value = strings.ToLower(value)
        switch value </span>{
        case string(Source_Legacy):<span class="cov0" title="0">
                return Source_Legacy</span>
        case string(Source_Decade):<span class="cov0" title="0">
                return Source_Decade</span>
        case string(Source_Genre):<span class="cov0" title="0">
                return Source_Genre</span>
        case string(Source_Deezer):<span class="cov0" title="0">
                return Source_Deezer</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func (s Source) String() string <span class="cov0" title="0">{
        return string(s)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package model

import "go.uber.org/zap/zapcore"

// //////////////////////////////////////////////////
// theme

type ThemeId int64

type Theme struct {
        Id     ThemeId
        Title  string
        ImgUrl string

        // consolidated data
        Questions []*ThemeQuestion
}

func (o *Theme) Copy() *Theme <span class="cov0" title="0">{
        return &amp;Theme{
                Id:     o.Id,
                Title:  o.Title,
                ImgUrl: o.ImgUrl,
        }
}</span>

func (o *Theme) Equal(other *Theme) bool <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return other == nil
        }</span>
        <span class="cov0" title="0">if other == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return (o.Id == other.Id) &amp;&amp;
                (o.Title == other.Title) &amp;&amp;
                (o.ImgUrl == other.ImgUrl)</span>
}

func (o *Theme) MarshalLogObject(enc zapcore.ObjectEncoder) error <span class="cov0" title="0">{
        enc.AddInt64("id", int64(o.Id))
        enc.AddString("title", o.Title)
        enc.AddString("img-url", o.ImgUrl)
        if o.Questions != nil </span><span class="cov0" title="0">{
                enc.AddInt("nb-questions", len(o.Questions))
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package model

import "go.uber.org/zap/zapcore"

// //////////////////////////////////////////////////
// theme filter

type ThemeFilter struct {
        ThemeId ThemeId
}

func (o *ThemeFilter) MarshalLogObject(enc zapcore.ObjectEncoder) error <span class="cov0" title="0">{
        if o.ThemeId != 0 </span><span class="cov0" title="0">{
                enc.AddInt64("theme-id", int64(o.ThemeId))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *ThemeFilter) IsMatching(candidate *Theme) bool <span class="cov0" title="0">{
        if o.ThemeId != 0 </span><span class="cov0" title="0">{
                if candidate.Id == o.ThemeId </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package model

import "go.uber.org/zap/zapcore"

// //////////////////////////////////////////////////
// theme question

type ThemeQuestionId int64

type ThemeQuestion struct {
        Id      ThemeQuestionId
        ThemeId ThemeId
        MusicId MusicId
        Text    string
        Hint    string

        // consolidated data
        Music *Music
}

func (o *ThemeQuestion) Copy() *ThemeQuestion <span class="cov0" title="0">{
        return &amp;ThemeQuestion{
                Id:      o.Id,
                ThemeId: o.ThemeId,
                MusicId: o.MusicId,
                Text:    o.Text,
                Hint:    o.Hint,
        }
}</span>

func (o *ThemeQuestion) MarshalLogObject(enc zapcore.ObjectEncoder) error <span class="cov0" title="0">{
        enc.AddInt64("id", int64(o.Id))
        enc.AddInt64("theme-id", int64(o.ThemeId))
        enc.AddInt64("music-id", int64(o.MusicId))
        enc.AddString("text", o.Text)
        if o.Hint != "" </span><span class="cov0" title="0">{
                enc.AddString("hint", o.Hint)
        }</span>
        <span class="cov0" title="0">if o.Music != nil </span><span class="cov0" title="0">{
                enc.AddObject("music", o.Music)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package model

import "go.uber.org/zap/zapcore"

// //////////////////////////////////////////////////
// theme questionfilter

type ThemeQuestionFilter struct {
        ThemeQuestionId ThemeQuestionId
        ThemeId         ThemeId
}

func (o *ThemeQuestionFilter) MarshalLogObject(enc zapcore.ObjectEncoder) error <span class="cov0" title="0">{
        if o.ThemeQuestionId != 0 </span><span class="cov0" title="0">{
                enc.AddInt64("theme-question-id", int64(o.ThemeQuestionId))
        }</span>
        <span class="cov0" title="0">if o.ThemeId != 0 </span><span class="cov0" title="0">{
                enc.AddInt64("theme-id", int64(o.ThemeId))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *ThemeQuestionFilter) IsMatching(candidate *ThemeQuestion) bool <span class="cov0" title="0">{
        if o.ThemeQuestionId != 0 </span><span class="cov0" title="0">{
                if candidate.Id == o.ThemeQuestionId </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">if o.ThemeId != 0 </span><span class="cov0" title="0">{
                if candidate.ThemeId == o.ThemeId </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package store

import (
        "context"
        "sync"

        "github.com/gre-ory/amnezic-go/internal/model"
)

// //////////////////////////////////////////////////
// game memory store

func NewGameMemoryStore() GameStore <span class="cov0" title="0">{
        return &amp;gameMemoryStore{
                games: make(map[model.GameId]*model.Game),
        }
}</span>

type gameMemoryStore struct {
        games     map[model.GameId]*model.Game
        gamesLock sync.RWMutex
}

func (s *gameMemoryStore) Create(ctx context.Context, game *model.Game) (*model.Game, error) <span class="cov0" title="0">{
        s.gamesLock.Lock()
        defer s.gamesLock.Unlock()

        gameNumber := len(s.games) + 1
        game.Id = model.NewGameId(gameNumber)
        game.Version = 1
        s.games[game.Id] = game
        return s.games[game.Id], nil
}</span>

func (s *gameMemoryStore) Retrieve(ctx context.Context, id model.GameId) (*model.Game, error) <span class="cov0" title="0">{
        s.gamesLock.Lock()
        defer s.gamesLock.Unlock()

        game, found := s.games[id]
        if !found </span><span class="cov0" title="0">{
                return nil, model.ErrGameNotFound
        }</span>
        <span class="cov0" title="0">return game, nil</span>
}

func (s *gameMemoryStore) Update(ctx context.Context, game *model.Game) (*model.Game, error) <span class="cov0" title="0">{
        s.gamesLock.Lock()
        defer s.gamesLock.Unlock()

        orig, found := s.games[game.Id]
        if !found </span><span class="cov0" title="0">{
                return nil, model.ErrGameNotFound
        }</span>
        <span class="cov0" title="0">if orig.Version != game.Version </span><span class="cov0" title="0">{
                return nil, model.ErrConcurrentUpdate
        }</span>
        <span class="cov0" title="0">game.Version++
        s.games[game.Id] = game
        return s.games[game.Id], nil</span>
}

func (s *gameMemoryStore) Delete(ctx context.Context, id model.GameId) error <span class="cov0" title="0">{
        s.gamesLock.Lock()
        defer s.gamesLock.Unlock()

        _, found := s.games[id]
        if !found </span><span class="cov0" title="0">{
                return model.ErrGameNotFound
        }</span>
        <span class="cov0" title="0">delete(s.games, id)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package store

import (
        "context"
        "encoding/json"
        "fmt"
        "math/rand"
        "strings"

        "github.com/gre-ory/amnezic-go/internal/model"
        "github.com/gre-ory/amnezic-go/internal/util"
        "go.uber.org/zap"

        _ "embed"
)

// //////////////////////////////////////////////////
// legacy music store

const (
        RootPath_AmnezicDotCom = "http://cache.amnezic.com/"
        RootPath_FreeDotFr     = "http://gregory.valigiani.free.fr/amnezic/"
)

func NewLegacyMusicStore(logger *zap.Logger, rootPath string) GameQuestionStore <span class="cov1" title="2">{
        store := &amp;legacyMusicStore{
                logger:           logger,
                rootPath:         strings.TrimRight(rootPath, "/"),
                mediaIdsBySource: make(map[model.Source][]int64, 10),
                media:            make(map[int64]*JsonLegacyMedia, 2000),
                genres:           make(map[int64]*JsonLegacyGenre, 200),
        }
        store.Load()
        return store
}</span>

// //////////////////////////////////////////////////
// implementation

type legacyMusicStore struct {
        logger           *zap.Logger
        rootPath         string
        mediaIdsBySource map[model.Source][]int64
        media            map[int64]*JsonLegacyMedia
        genres           map[int64]*JsonLegacyGenre
}

func (s *legacyMusicStore) SelectRandomQuestions(ctx context.Context, settings model.GameSettings) ([]*model.GameQuestion, error) <span class="cov1" title="2">{

        //
        // validate
        //

        if settings.NbQuestion &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid number of question")
        }</span>
        <span class="cov1" title="2">if settings.NbAnswer &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid number of answer")
        }</span>

        //
        // random seed
        //

        <span class="cov1" title="2">rand.Seed(settings.Seed)

        //
        // select &amp; shuffle media ids
        //

        mediaIds := make([]int64, 0, 2000)
        for _, source := range settings.Sources </span><span class="cov1" title="1">{
                mediaIds = append(mediaIds, s.mediaIdsBySource[source]...)
        }</span>
        <span class="cov1" title="2">util.Shuffle(mediaIds)

        //
        // select subset
        //

        if len(mediaIds) &gt; settings.NbQuestion </span><span class="cov1" title="1">{
                mediaIds = mediaIds[:settings.NbQuestion]
        }</span>

        //
        // building questions
        //

        <span class="cov1" title="2">questions := make([]*model.GameQuestion, 0, settings.NbQuestion)
        for _, mediaId := range mediaIds </span><span class="cov2" title="5">{
                media := s.media[mediaId]
                genre := s.genres[media.GenreId]
                questions = append(questions, s.toQuestion(ctx, genre, media, settings.NbAnswer))
        }</span>

        <span class="cov1" title="2">return questions, nil</span>
}

func (s *legacyMusicStore) toQuestion(ctx context.Context, genre *JsonLegacyGenre, media *JsonLegacyMedia, nbAnswer int) *model.GameQuestion <span class="cov2" title="5">{
        return &amp;model.GameQuestion{
                Theme:   s.toTheme(ctx, genre),
                Music:   s.toMusic(ctx, media),
                Answers: s.toAnswers(ctx, genre, media, nbAnswer),
        }
}</span>

func (s *legacyMusicStore) toTheme(ctx context.Context, genre *JsonLegacyGenre) *model.GameTheme <span class="cov2" title="5">{
        return &amp;model.GameTheme{
                Title: genre.Genre,
        }
}</span>

func (s *legacyMusicStore) toMusic(ctx context.Context, media *JsonLegacyMedia) *model.Music <span class="cov2" title="5">{
        return &amp;model.Music{
                Id:     model.MusicId(media.Id),
                Name:   media.Title,
                Mp3Url: s.toMp3Url(ctx, media),
                Artist: s.toArtist(ctx, media.Artist),
        }
}</span>

func (s *legacyMusicStore) toMp3Url(ctx context.Context, media *JsonLegacyMedia) string <span class="cov2" title="5">{
        if s.rootPath != "" </span><span class="cov2" title="5">{
                return fmt.Sprintf("%s/%s", s.rootPath, media.MusicFileName)
        }</span>
        <span class="cov0" title="0">return media.MusicFileName</span>
}

func (s *legacyMusicStore) toArtist(ctx context.Context, artist *JsonLegacyArtist) *model.MusicArtist <span class="cov2" title="5">{
        if artist == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov2" title="5">return &amp;model.MusicArtist{
                Name: artist.Name,
        }</span>
}

func (s *legacyMusicStore) toAnswers(ctx context.Context, genre *JsonLegacyGenre, media *JsonLegacyMedia, nbAnswer int) []*model.GameAnswer <span class="cov2" title="5">{

        others := util.Filter(genre.Media, func(other *JsonLegacyMedia) bool </span><span class="cov7" title="372">{ return other.Id != media.Id }</span>)

        <span class="cov2" title="5">util.Shuffle(others)

        if len(others) &gt; nbAnswer-1 </span><span class="cov2" title="5">{
                others = others[:nbAnswer-1]
        }</span>

        <span class="cov2" title="5">answers := util.Convert(others, func(other *JsonLegacyMedia) *model.GameAnswer </span><span class="cov3" title="10">{ return s.toAnswer(ctx, other, false) }</span>)
        <span class="cov2" title="5">answers = append(answers, s.toAnswer(ctx, media, true))

        util.Shuffle(answers)

        return answers</span>
}

func (s *legacyMusicStore) toAnswer(ctx context.Context, media *JsonLegacyMedia, correct bool) *model.GameAnswer <span class="cov3" title="15">{
        if media.Artist == nil </span><span class="cov0" title="0">{
                return &amp;model.GameAnswer{
                        Text:    media.Title,
                        Correct: correct,
                }
        }</span>
        <span class="cov3" title="15">return &amp;model.GameAnswer{
                Text:    media.Artist.Name,
                Hint:    media.Title,
                Correct: correct,
        }</span>
}

// //////////////////////////////////////////////////
// load

//go:embed resources/decade.json
var decadeJsonBytes []byte

//go:embed resources/genre.json
var genreJsonBytes []byte

//go:embed resources/legacy.json
var legacyJsonBytes []byte

func (s *legacyMusicStore) Load() *legacyMusicStore <span class="cov1" title="2">{

        s.LoadSource(model.Source_Legacy, legacyJsonBytes)
        s.LoadSource(model.Source_Decade, decadeJsonBytes)
        s.LoadSource(model.Source_Genre, genreJsonBytes)

        return s
}</span>

func (s *legacyMusicStore) LoadSource(source model.Source, embedBytes []byte) *legacyMusicStore <span class="cov2" title="6">{

        jsonLegacy := JsonLegacy{}
        if err := json.Unmarshal(embedBytes, &amp;jsonLegacy); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov2" title="6">sourceIndex := len(s.mediaIdsBySource)
        sourceId := int64(1000 * 1000 * (sourceIndex + 1))

        mediaIds := make([]int64, 0, 1000)

        for genreIndex, genre := range jsonLegacy.Genres </span><span class="cov5" title="82">{
                genre.Id = sourceId + int64(1000*(genreIndex+1))
                s.genres[genre.Id] = genre
                for mediaIndex, media := range genre.Media </span><span class="cov10" title="3686">{
                        media.GenreId = genre.Id
                        media.Id = genre.Id + int64(mediaIndex) + 1
                        mediaIds = append(mediaIds, media.Id)
                        s.media[media.Id] = media
                }</span>
        }

        <span class="cov2" title="6">s.mediaIdsBySource[source] = mediaIds

        return s</span>
}

type JsonLegacy struct {
        Genres []*JsonLegacyGenre `json:"genres,omitempty"`
}

type JsonLegacyGenre struct {
        Id    int64              `json:"id,omitempty"`
        Genre string             `json:"genre,omitempty"`
        Media []*JsonLegacyMedia `json:"media,omitempty"`
}

type JsonLegacyMedia struct {
        Id            int64             `json:"id,omitempty"`
        GenreId       int64             `json:"genreId,omitempty"`
        Title         string            `json:"title,omitempty"`
        MusicFileName string            `json:"music,omitempty"`
        Artist        *JsonLegacyArtist `json:"artist,omitempty"`
}

type JsonLegacyArtist struct {
        Name string `json:"name,omitempty"`
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package store

import (
        "context"
        "sync"

        "github.com/gre-ory/amnezic-go/internal/model"
)

// //////////////////////////////////////////////////
// music album memory store

func NewMusicAlbumMemoryStore() MusicAlbumStore <span class="cov0" title="0">{
        return &amp;musicAlbumMemoryStore{
                musicAlbums: make(map[model.MusicAlbumId]*model.MusicAlbum),
        }
}</span>

type musicAlbumMemoryStore struct {
        musicAlbums     map[model.MusicAlbumId]*model.MusicAlbum
        musicAlbumsLock sync.RWMutex
}

func (s *musicAlbumMemoryStore) Create(ctx context.Context, musicAlbum *model.MusicAlbum) (*model.MusicAlbum, error) <span class="cov0" title="0">{
        s.musicAlbumsLock.Lock()
        defer s.musicAlbumsLock.Unlock()

        musicAlbumNumber := len(s.musicAlbums) + 1
        musicAlbum.Id = model.MusicAlbumId(musicAlbumNumber)
        s.musicAlbums[musicAlbum.Id] = musicAlbum.Copy()
        return s.musicAlbums[musicAlbum.Id].Copy(), nil
}</span>

func (s *musicAlbumMemoryStore) Retrieve(ctx context.Context, id model.MusicAlbumId) (*model.MusicAlbum, error) <span class="cov0" title="0">{
        s.musicAlbumsLock.Lock()
        defer s.musicAlbumsLock.Unlock()

        musicAlbum, found := s.musicAlbums[id]
        if !found </span><span class="cov0" title="0">{
                return nil, model.ErrMusicAlbumNotFound
        }</span>
        <span class="cov0" title="0">return musicAlbum.Copy(), nil</span>
}

func (s *musicAlbumMemoryStore) RetrieveByDeezerId(ctx context.Context, deezerId model.DeezerAlbumId) (*model.MusicAlbum, error) <span class="cov0" title="0">{
        s.musicAlbumsLock.Lock()
        defer s.musicAlbumsLock.Unlock()

        if deezerId == 0 </span><span class="cov0" title="0">{
                return nil, model.ErrMusicAlbumNotFound
        }</span>

        <span class="cov0" title="0">for _, musicAlbum := range s.musicAlbums </span><span class="cov0" title="0">{
                if musicAlbum.DeezerAlbumId == deezerId </span><span class="cov0" title="0">{
                        return musicAlbum.Copy(), nil
                }</span>
        }
        <span class="cov0" title="0">return nil, model.ErrMusicAlbumNotFound</span>
}

func (s *musicAlbumMemoryStore) Update(ctx context.Context, musicAlbum *model.MusicAlbum) (*model.MusicAlbum, error) <span class="cov0" title="0">{
        s.musicAlbumsLock.Lock()
        defer s.musicAlbumsLock.Unlock()

        _, found := s.musicAlbums[musicAlbum.Id]
        if !found </span><span class="cov0" title="0">{
                return nil, model.ErrMusicAlbumNotFound
        }</span>
        <span class="cov0" title="0">s.musicAlbums[musicAlbum.Id] = musicAlbum.Copy()
        return s.musicAlbums[musicAlbum.Id].Copy(), nil</span>
}

func (s *musicAlbumMemoryStore) Delete(ctx context.Context, id model.MusicAlbumId) error <span class="cov0" title="0">{
        s.musicAlbumsLock.Lock()
        defer s.musicAlbumsLock.Unlock()

        _, found := s.musicAlbums[id]
        if !found </span><span class="cov0" title="0">{
                return model.ErrMusicAlbumNotFound
        }</span>
        <span class="cov0" title="0">delete(s.musicAlbums, id)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package store

import (
        "context"
        "sync"

        "github.com/gre-ory/amnezic-go/internal/model"
)

// //////////////////////////////////////////////////
// music album memory store

func NewMusicArtistMemoryStore() MusicArtistStore <span class="cov0" title="0">{
        return &amp;musicArtistMemoryStore{
                musicArtists: make(map[model.MusicArtistId]*model.MusicArtist),
        }
}</span>

type musicArtistMemoryStore struct {
        musicArtists     map[model.MusicArtistId]*model.MusicArtist
        musicArtistsLock sync.RWMutex
}

func (s *musicArtistMemoryStore) Create(ctx context.Context, musicArtist *model.MusicArtist) (*model.MusicArtist, error) <span class="cov0" title="0">{
        s.musicArtistsLock.Lock()
        defer s.musicArtistsLock.Unlock()

        musicArtistNumber := len(s.musicArtists) + 1
        musicArtist.Id = model.MusicArtistId(musicArtistNumber)
        s.musicArtists[musicArtist.Id] = musicArtist.Copy()
        return s.musicArtists[musicArtist.Id].Copy(), nil
}</span>

func (s *musicArtistMemoryStore) Retrieve(ctx context.Context, id model.MusicArtistId) (*model.MusicArtist, error) <span class="cov0" title="0">{
        s.musicArtistsLock.Lock()
        defer s.musicArtistsLock.Unlock()

        musicArtist, found := s.musicArtists[id]
        if !found </span><span class="cov0" title="0">{
                return nil, model.ErrMusicArtistNotFound
        }</span>
        <span class="cov0" title="0">return musicArtist.Copy(), nil</span>
}

func (s *musicArtistMemoryStore) RetrieveByDeezerId(ctx context.Context, deezerId model.DeezerArtistId) (*model.MusicArtist, error) <span class="cov0" title="0">{
        s.musicArtistsLock.Lock()
        defer s.musicArtistsLock.Unlock()

        if deezerId == 0 </span><span class="cov0" title="0">{
                return nil, model.ErrMusicArtistNotFound
        }</span>

        <span class="cov0" title="0">for _, musicArtist := range s.musicArtists </span><span class="cov0" title="0">{
                if musicArtist.DeezerArtistId == deezerId </span><span class="cov0" title="0">{
                        return musicArtist.Copy(), nil
                }</span>
        }
        <span class="cov0" title="0">return nil, model.ErrMusicArtistNotFound</span>
}

func (s *musicArtistMemoryStore) Update(ctx context.Context, musicArtist *model.MusicArtist) (*model.MusicArtist, error) <span class="cov0" title="0">{
        s.musicArtistsLock.Lock()
        defer s.musicArtistsLock.Unlock()

        _, found := s.musicArtists[musicArtist.Id]
        if !found </span><span class="cov0" title="0">{
                return nil, model.ErrMusicArtistNotFound
        }</span>
        <span class="cov0" title="0">s.musicArtists[musicArtist.Id] = musicArtist.Copy()
        return s.musicArtists[musicArtist.Id].Copy(), nil</span>
}

func (s *musicArtistMemoryStore) Delete(ctx context.Context, id model.MusicArtistId) error <span class="cov0" title="0">{
        s.musicArtistsLock.Lock()
        defer s.musicArtistsLock.Unlock()

        _, found := s.musicArtists[id]
        if !found </span><span class="cov0" title="0">{
                return model.ErrMusicArtistNotFound
        }</span>
        <span class="cov0" title="0">delete(s.musicArtists, id)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package store

import (
        "context"
        "sync"

        "github.com/gre-ory/amnezic-go/internal/model"
)

// //////////////////////////////////////////////////
// music album memory store

func NewMusicGenreMemoryStore() MusicGenreStore <span class="cov0" title="0">{
        return &amp;musicGenreMemoryStore{
                musicGenres: make(map[model.MusicGenreId]*model.MusicGenre),
        }
}</span>

type musicGenreMemoryStore struct {
        musicGenres     map[model.MusicGenreId]*model.MusicGenre
        musicGenresLock sync.RWMutex
}

func (s *musicGenreMemoryStore) Create(ctx context.Context, musicGenre *model.MusicGenre) (*model.MusicGenre, error) <span class="cov0" title="0">{
        s.musicGenresLock.Lock()
        defer s.musicGenresLock.Unlock()

        musicGenreNumber := len(s.musicGenres) + 1
        musicGenre.Id = model.MusicGenreId(musicGenreNumber)
        s.musicGenres[musicGenre.Id] = musicGenre.Copy()
        return s.musicGenres[musicGenre.Id].Copy(), nil
}</span>

func (s *musicGenreMemoryStore) Retrieve(ctx context.Context, id model.MusicGenreId) (*model.MusicGenre, error) <span class="cov0" title="0">{
        s.musicGenresLock.Lock()
        defer s.musicGenresLock.Unlock()

        musicGenre, found := s.musicGenres[id]
        if !found </span><span class="cov0" title="0">{
                return nil, model.ErrMusicGenreNotFound
        }</span>
        <span class="cov0" title="0">return musicGenre.Copy(), nil</span>
}

func (s *musicGenreMemoryStore) RetrieveByDeezerId(ctx context.Context, deezerId model.DeezerGenreId) (*model.MusicGenre, error) <span class="cov0" title="0">{
        s.musicGenresLock.Lock()
        defer s.musicGenresLock.Unlock()

        if deezerId == 0 </span><span class="cov0" title="0">{
                return nil, model.ErrMusicGenreNotFound
        }</span>

        <span class="cov0" title="0">for _, musicGenre := range s.musicGenres </span><span class="cov0" title="0">{
                if musicGenre.DeezerGenreId == deezerId </span><span class="cov0" title="0">{
                        return musicGenre.Copy(), nil
                }</span>
        }
        <span class="cov0" title="0">return nil, model.ErrMusicGenreNotFound</span>
}

func (s *musicGenreMemoryStore) Update(ctx context.Context, musicGenre *model.MusicGenre) (*model.MusicGenre, error) <span class="cov0" title="0">{
        s.musicGenresLock.Lock()
        defer s.musicGenresLock.Unlock()

        _, found := s.musicGenres[musicGenre.Id]
        if !found </span><span class="cov0" title="0">{
                return nil, model.ErrMusicGenreNotFound
        }</span>
        <span class="cov0" title="0">s.musicGenres[musicGenre.Id] = musicGenre.Copy()
        return s.musicGenres[musicGenre.Id].Copy(), nil</span>
}

func (s *musicGenreMemoryStore) Delete(ctx context.Context, id model.MusicGenreId) error <span class="cov0" title="0">{
        s.musicGenresLock.Lock()
        defer s.musicGenresLock.Unlock()

        _, found := s.musicGenres[id]
        if !found </span><span class="cov0" title="0">{
                return model.ErrMusicGenreNotFound
        }</span>
        <span class="cov0" title="0">delete(s.musicGenres, id)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package store

import (
        "context"
        "sync"

        "github.com/gre-ory/amnezic-go/internal/model"
)

// //////////////////////////////////////////////////
// music memory store

func NewMusicMemoryStore() MusicStore <span class="cov0" title="0">{
        return &amp;musicMemoryStore{
                musics: make(map[model.MusicId]*model.Music),
        }
}</span>

type musicMemoryStore struct {
        musics     map[model.MusicId]*model.Music
        musicsLock sync.RWMutex
}

func (s *musicMemoryStore) Create(ctx context.Context, music *model.Music) (*model.Music, error) <span class="cov0" title="0">{
        s.musicsLock.Lock()
        defer s.musicsLock.Unlock()

        musicNumber := len(s.musics) + 1
        music.Id = model.MusicId(musicNumber)
        s.musics[music.Id] = music.Copy()
        return s.musics[music.Id].Copy(), nil
}</span>

func (s *musicMemoryStore) Retrieve(ctx context.Context, id model.MusicId) (*model.Music, error) <span class="cov0" title="0">{
        s.musicsLock.Lock()
        defer s.musicsLock.Unlock()

        music, found := s.musics[id]
        if !found </span><span class="cov0" title="0">{
                return nil, model.ErrMusicNotFound
        }</span>
        <span class="cov0" title="0">return music.Copy(), nil</span>
}

func (s *musicMemoryStore) RetrieveByDeezerId(ctx context.Context, deezerId model.DeezerMusicId) (*model.Music, error) <span class="cov0" title="0">{
        s.musicsLock.Lock()
        defer s.musicsLock.Unlock()

        if deezerId == 0 </span><span class="cov0" title="0">{
                return nil, model.ErrMusicNotFound
        }</span>

        <span class="cov0" title="0">for _, music := range s.musics </span><span class="cov0" title="0">{
                if music.DeezerMusicId == deezerId </span><span class="cov0" title="0">{
                        return music.Copy(), nil
                }</span>
        }
        <span class="cov0" title="0">return nil, model.ErrMusicNotFound</span>
}

func (s *musicMemoryStore) Update(ctx context.Context, music *model.Music) (*model.Music, error) <span class="cov0" title="0">{
        s.musicsLock.Lock()
        defer s.musicsLock.Unlock()

        _, found := s.musics[music.Id]
        if !found </span><span class="cov0" title="0">{
                return nil, model.ErrMusicNotFound
        }</span>
        <span class="cov0" title="0">s.musics[music.Id] = music.Copy()
        return s.musics[music.Id].Copy(), nil</span>
}

func (s *musicMemoryStore) Delete(ctx context.Context, id model.MusicId) error <span class="cov0" title="0">{
        s.musicsLock.Lock()
        defer s.musicsLock.Unlock()

        _, found := s.musics[id]
        if !found </span><span class="cov0" title="0">{
                return model.ErrMusicNotFound
        }</span>
        <span class="cov0" title="0">delete(s.musics, id)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package store

import (
        "context"
        "sync"

        "github.com/gre-ory/amnezic-go/internal/model"
)

// //////////////////////////////////////////////////
// theme memory store

func NewThemeMemoryStore() ThemeStore <span class="cov0" title="0">{
        return &amp;themeMemoryStore{
                themes: make(map[model.ThemeId]*model.Theme),
        }
}</span>

type themeMemoryStore struct {
        themes     map[model.ThemeId]*model.Theme
        themesLock sync.RWMutex
}

func (s *themeMemoryStore) Create(ctx context.Context, theme *model.Theme) (*model.Theme, error) <span class="cov0" title="0">{
        s.themesLock.Lock()
        defer s.themesLock.Unlock()

        themeNumber := len(s.themes) + 1
        theme.Id = model.ThemeId(themeNumber)
        s.themes[theme.Id] = theme
        return s.themes[theme.Id], nil
}</span>

func (s *themeMemoryStore) Retrieve(ctx context.Context, id model.ThemeId) (*model.Theme, error) <span class="cov0" title="0">{
        s.themesLock.Lock()
        defer s.themesLock.Unlock()

        theme, found := s.themes[id]
        if !found </span><span class="cov0" title="0">{
                return nil, model.ErrThemeNotFound
        }</span>
        <span class="cov0" title="0">return theme, nil</span>
}

func (s *themeMemoryStore) Update(ctx context.Context, theme *model.Theme) (*model.Theme, error) <span class="cov0" title="0">{
        s.themesLock.Lock()
        defer s.themesLock.Unlock()

        _, found := s.themes[theme.Id]
        if !found </span><span class="cov0" title="0">{
                return nil, model.ErrThemeNotFound
        }</span>
        <span class="cov0" title="0">s.themes[theme.Id] = theme
        return s.themes[theme.Id], nil</span>
}

func (s *themeMemoryStore) Delete(ctx context.Context, filter *model.ThemeFilter) error <span class="cov0" title="0">{
        s.themesLock.Lock()
        defer s.themesLock.Unlock()

        for id, theme := range s.themes </span><span class="cov0" title="0">{
                if filter.IsMatching(theme) </span><span class="cov0" title="0">{
                        delete(s.themes, id)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *themeMemoryStore) List(ctx context.Context, filter *model.ThemeFilter) ([]*model.Theme, error) <span class="cov0" title="0">{
        s.themesLock.Lock()
        defer s.themesLock.Unlock()

        themes := make([]*model.Theme, 0, len(s.themes))
        for _, theme := range s.themes </span><span class="cov0" title="0">{
                if filter.IsMatching(theme) </span><span class="cov0" title="0">{
                        themes = append(themes, theme.Copy())
                }</span>
        }

        <span class="cov0" title="0">return themes, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package store

import (
        "context"
        "sync"

        "github.com/gre-ory/amnezic-go/internal/model"
)

// //////////////////////////////////////////////////
// themeQuestion memory store

func NewThemeQuestionMemoryStore() ThemeQuestionStore <span class="cov0" title="0">{
        return &amp;themeQuestionMemoryStore{
                themeQuestions: make(map[model.ThemeQuestionId]*model.ThemeQuestion),
        }
}</span>

type themeQuestionMemoryStore struct {
        themeQuestions     map[model.ThemeQuestionId]*model.ThemeQuestion
        themeQuestionsLock sync.RWMutex
}

func (s *themeQuestionMemoryStore) Create(ctx context.Context, themeQuestion *model.ThemeQuestion) (*model.ThemeQuestion, error) <span class="cov0" title="0">{
        s.themeQuestionsLock.Lock()
        defer s.themeQuestionsLock.Unlock()

        themeQuestionNumber := len(s.themeQuestions) + 1
        themeQuestion.Id = model.ThemeQuestionId(themeQuestionNumber)
        s.themeQuestions[themeQuestion.Id] = themeQuestion
        return s.themeQuestions[themeQuestion.Id], nil
}</span>

func (s *themeQuestionMemoryStore) Retrieve(ctx context.Context, id model.ThemeQuestionId) (*model.ThemeQuestion, error) <span class="cov0" title="0">{
        s.themeQuestionsLock.Lock()
        defer s.themeQuestionsLock.Unlock()

        themeQuestion, found := s.themeQuestions[id]
        if !found </span><span class="cov0" title="0">{
                return nil, model.ErrThemeQuestionNotFound
        }</span>
        <span class="cov0" title="0">return themeQuestion, nil</span>
}

func (s *themeQuestionMemoryStore) Update(ctx context.Context, themeQuestion *model.ThemeQuestion) (*model.ThemeQuestion, error) <span class="cov0" title="0">{
        s.themeQuestionsLock.Lock()
        defer s.themeQuestionsLock.Unlock()

        _, found := s.themeQuestions[themeQuestion.Id]
        if !found </span><span class="cov0" title="0">{
                return nil, model.ErrThemeQuestionNotFound
        }</span>
        <span class="cov0" title="0">s.themeQuestions[themeQuestion.Id] = themeQuestion
        return s.themeQuestions[themeQuestion.Id], nil</span>
}

func (s *themeQuestionMemoryStore) Delete(ctx context.Context, filter *model.ThemeQuestionFilter) error <span class="cov0" title="0">{
        s.themeQuestionsLock.Lock()
        defer s.themeQuestionsLock.Unlock()

        for id, question := range s.themeQuestions </span><span class="cov0" title="0">{
                if filter.IsMatching(question) </span><span class="cov0" title="0">{
                        delete(s.themeQuestions, id)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *themeQuestionMemoryStore) List(ctx context.Context, filter *model.ThemeQuestionFilter) ([]*model.ThemeQuestion, error) <span class="cov0" title="0">{
        s.themeQuestionsLock.Lock()
        defer s.themeQuestionsLock.Unlock()

        questions := make([]*model.ThemeQuestion, 0, len(s.themeQuestions))
        for _, question := range s.themeQuestions </span><span class="cov0" title="0">{
                if filter.IsMatching(question) </span><span class="cov0" title="0">{
                        questions = append(questions, question.Copy())
                }</span>
        }

        <span class="cov0" title="0">return questions, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
